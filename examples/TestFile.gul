trait TContractTest {

}

struct ContractTestImpl : TContractTest {

}

struct Example<G>
where G : TContractTest {

}

// For this to work we will need to support using `where` to modify the abilities for `G`
// (i.e. store `TContractTest` as an inherited type within `G`)
struct HardTest<G> : Example<G>
where G : TContractTest {

}

struct AdvancedContractExample<T> {
    struct NestedExample<G>
    where G : TContractTest {

    }

    // This one is even harder than the one in the global context, this will require `NestedType` to be handled
    // properly (or we might need to create a `DependantType` to handle this case)
    struct NestedHardTest<G> : NestedExample<G>
    where G : TContractTest {

    }

    struct DependentTest : TContractTest {

    }

    // For this to work we will need to be properly handling dependent types (as `DependentTest` will be implicitly
    // converted to `AdvancedContractExample<T>.DependentTest`)
    const var hardDependentTest : NestedHardTest<DependentTest>;
}

func _start() -> Example<ContractTestImpl> {

}
